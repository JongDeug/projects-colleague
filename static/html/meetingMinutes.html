<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebRTC</title>
  <link rel="stylesheet" href="https://unpkg.com/mvp.css@1.12/mvp.css">
  <link rel="shortcut icon" href="#">
</head>
<body>
<header><h1>WebRTC</h1></header>
<main>
  <div id="welcome">
    <form>
      <input placeholder="email" required="" type="text">
      <button>Enter room</button>
    </form>
  </div>
  <div id="call">
    <div id="myStream"></div>
    <video id="myFace" autoplay="" playsinline="" width="400" height="400"></video>
    <button id="mute">Mute</button>
    <button id="camera">Turn Camera Off</button>
    <select id="cameras"></select>
    <div id="peerFaces">
      <video id="peerFace1" autoplay="" playsinline="" width="400" height="400"></video>
      <video id="peerFace2" autoplay="" playsinline="" width="400" height="400"></video>
      <video id="peerFace3" autoplay="" playsinline="" width="400" height="400"></video>
    </div>
  </div>
</main>

<script type="module">
  import { io } from "https://cdn.socket.io/4.4.1/socket.io.esm.min.js";

  const myFace = document.getElementById("myFace");
  const muteBtn = document.getElementById("mute");
  const cameraBtn = document.getElementById("camera");
  const camerasSelect = document.getElementById("cameras");

  const call = document.getElementById("call");

  call.hidden = true;

  let myStream;
  let streams = new Array();
  let muted = false;
  let cameraOff = false;
  let roomName;
  let email;
  let myPeerConnection;
  let peerConnections;

  // const socket = io('http://localhost:3000', {
  //   cors: {
  //     origin : '*'
  //   }
  // });
  // const socket = io('https://little-bobcat-56.loca.lt', {
  //     cors: {
  //       origin : 'https://master--preeminent-douhua-939041.netlify.app',
  //     }
  // });
  // const URL = "http://localhost:3000/";
  const URL = "https://16e4-112-217-167-202.ngrok-free.app/";
  const socket = io(URL, {
    withCredentials: true
  });

  // 시작
  const welcome = document.getElementById("welcome");
  const welcomeForm = welcome.querySelector("form");

  async function handleWelcomeSubmit(event) {
    event.preventDefault();
    const input = welcomeForm.querySelector("input");
    email = input.value;
    await initCall();
    input.value = "";
  }

  welcomeForm.addEventListener("submit", handleWelcomeSubmit);

  async function getCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cameras = devices.filter(device => device.kind === "videoinput");
      const currentCamera = myStream.getVideoTracks()[0];
      cameras.forEach(camera => {
        const option = document.createElement("option");
        option.value = camera.deviceId;
        option.innerText = camera.label;
        if (currentCamera.label == camera.label) {
          option.selected = true;
        }
        camerasSelect.appendChild(option);
      });
    } catch (e) {
      console.log(e);
    }
  }

  async function getMedia(deviceId) {
    const initialConstrains = {
      audio: true,
      video: { facingMode: "user" }
    };
    const cameraConstrains = {
      audio: true,
      video: { deviceId: { exact: deviceId } }
    };
    try {
      myStream = await navigator.mediaDevices.getUserMedia(
        deviceId ? cameraConstrains : initialConstrains
      );
      myFace.srcObject = myStream;
      if (!deviceId) {
        await getCameras();
      }
    } catch (e) {
      console.log(e);
    }
  }

  async function initCall() {
    welcome.hidden = true;
    call.hidden = false;
    await getMedia();
    roomName = "1234";
    socket.emit("join_room", { room: roomName, email: email });
    makeConnection(socket.id, email, socket, myStream);
  }

  function makeConnection(socketId, email, socket, myStream) {
    myPeerConnection = new RTCPeerConnection({
      iceServers: [
        {
          urls: [
            "stun:stun.l.google.com:19302",
            "stun:stun1.l.google.com:19302",
            "stun:stun2.l.google.com:19302",
            "stun:stun3.l.google.com:19302",
            "stun:stun4.l.google.com:19302"
          ]
        }
      ]
    });

    peerConnections = { ...peerConnections, [socketId]: myPeerConnection };

    myPeerConnection.addEventListener("icecandidate", (data) => {
      console.log("sent the candidate");
      socket.emit("ice", {
        ice: data.candidate,
        iceSendId: socket.id,
        iceReceiveId: socketId
      });
    });

    // 그냥 데이터스트림 저장하는 변수 설정해놓고 addStream event trigger시 다 넣는걸로 하자
    myPeerConnection.addEventListener("addstream", (data) => {
      console.log("got an event from my peer");
      streams.push(data.stream);
      renderStream();
    });

    // ontrack?
    myStream.getTracks().forEach(track => myPeerConnection.addTrack(track, myStream));
  }

  function renderStream() {
    const peerFace1 = document.getElementById("peerFace1");
    const peerFace2 = document.getElementById("peerFace2");
    const peerFace3 = document.getElementById("peerFace3");

    // console.log(streams);
    peerFace1.srcObject = streams[0];
    peerFace2.srcObject = streams[1];
    peerFace3.srcObject = streams[2];
  }

  // ===========================================================================

  function handleMuteClick() {
    myStream.getAudioTracks().forEach(track => {
      track.enabled = !track.enabled;
    });

    if (!muted) {
      muteBtn.innerText = "Unmute";
      muted = true;
    } else {
      muteBtn.innerText = "Mute";
      muted = false;
    }
  }

  function handleCameraClick() {
    myStream.getVideoTracks().forEach(track => {
      track.enabled = !track.enabled;
    });
    if (cameraOff) {
      cameraBtn.innerText = "Turn Camera Off";
      cameraOff = false;
    } else {
      cameraBtn.innerText = "Turn Camera On";
      cameraOff = true;
    }
  }

  async function handleCameraChange() {
    await getMedia(camerasSelect.value);
    const videoTrack = myStream.getVideoTracks()[0];
    // 이 부분을 배열로해서 전달하기!
    // test
    for (const peerConnection of peerConnections) {
      const videoSender = peerConnection.getSenders().find((sender) => sender.track.kind === "video");
      await videoSender.replaceTrack(videoTrack);
    }
    // await videoSender.replaceTrack(videoTrack);
  }

  muteBtn.addEventListener("click", handleMuteClick);
  cameraBtn.addEventListener("click", handleCameraClick);
  camerasSelect.addEventListener("input", handleCameraChange);

  // ===========================================================================

  // 먼저 들어온 놈
  socket.on("all_users", async (allUsers) => {
    let length = allUsers.length;
    // console.log(length);
    for (let i = 0; i < length; i++) {
      makeConnection(allUsers[i].id, allUsers[i].email, socket, myStream);

      // console.log(peerConnections);

      let peerConnection = peerConnections[allUsers[i].id];
      if (peerConnection) {
        const offer = await peerConnection.createOffer();
        // console.log(offer);
        await peerConnection.setLocalDescription(offer);
        // console.log(peerConnection);
        console.log(`sent the offer`);
        socket.emit("offer", {
          offer: offer,
          offerSendId: socket.id,
          offerSendEmail: email,
          offerReceiveId: allUsers[i].id
        });
      }
    }
  });

  // 나중에 들어온 놈
  socket.on("getOffer", async (offer) => {
    // console.log(offer);
    console.log("received the offer");
    // create answer
    makeConnection(offer.offerSendId, offer.offerSendEmail, socket, myStream);

    let peerConnection = peerConnections[offer.offerSendId];
    if (peerConnection) {
      await peerConnection.setRemoteDescription(offer.offer);
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      console.log(`sent the answer`);
      socket.emit("answer", {
        answer: answer,
        answerSendId: socket.id,
        answerReceiveId: offer.offerSendId
      });
    }
  });

  // 먼저 들어온 놈
  socket.on("getAnswer", async (answer) => {
    console.log("received the answer");
    let peerConnection = peerConnections[answer.answerSendId];
    if (peerConnection) {
      await peerConnection.setRemoteDescription(answer.answer);
      // console.log(peerConnection);
    }
  });

  socket.on("getIce", (ice) => {
    let myPeerConnection = peerConnections[ice.iceSendId];
    if (myPeerConnection) {
      myPeerConnection.addIceCandidate(ice.ice).then(() => console.log("received the candidate"));
    }
  });

</script>
</body>
</html>