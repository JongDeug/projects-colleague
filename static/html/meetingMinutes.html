<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebRTC</title>
  <link rel="stylesheet" href="https://unpkg.com/mvp.css@1.12/mvp.css">
  <link rel="shortcut icon" href="#">
</head>
<body>
<header><h1>WebRTC</h1></header>
<main>
  <div id="welcome">
    <form>
      <input placeholder="email" required="" type="text">
      <button>Enter room</button>
    </form>
  </div>
  <div id="call">
    <div id="myStream"></div>
    <video id="myFace" autoplay="" playsinline="" width="400" height="400"></video>
    <button id="mute">Mute</button>
    <button id="camera">Turn Camera Off</button>
    <select id="cameras"></select>
    <video id="peerFace" autoplay="" playsinline="" width="400" height="400"></video>
  </div>
</main>

<script type="module">
  import { io } from "https://cdn.socket.io/4.4.1/socket.io.esm.min.js";

  const myFace = document.getElementById("myFace");
  const muteBtn = document.getElementById("mute");
  const cameraBtn = document.getElementById("camera");
  const camerasSelect = document.getElementById("cameras");

  const call = document.getElementById("call");

  call.hidden = true;

  let myStream;
  let muted = false;
  let cameraOff = false;
  let roomName;
  let myPeerConnection;

  // const socket = io('http://localhost:3000', {
  //   cors: {
  //     origin : '*'
  //   }
  // });
  // const socket = io('https://little-bobcat-56.loca.lt', {
  //     cors: {
  //       origin : 'https://master--preeminent-douhua-939041.netlify.app',
  //     }
  // });
  // const URL = "http://localhost:3000/";
  const URL = "https://2037-222-103-180-169.ngrok-free.app";
  const socket = io(URL, {
    withCredentials: true
  });

  // 시작
  const welcome = document.getElementById("welcome");
  const welcomeForm = welcome.querySelector("form");
  async function handleWelcomeSubmit(event) {
    event.preventDefault();
    const input = welcomeForm.querySelector("input");
    await initCall();
    await join(input.value);
    input.value = "";
  }
  welcomeForm.addEventListener("submit", handleWelcomeSubmit);

  async function getCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cameras = devices.filter(device => device.kind === "videoinput");
      const currentCamera = myStream.getVideoTracks()[0];
      cameras.forEach(camera => {
        const option = document.createElement("option");
        option.value = camera.deviceId;
        option.innerText = camera.label;
        if (currentCamera.label == camera.label) {
          option.selected = true;
        }
        camerasSelect.appendChild(option);
      });
    } catch (e) {
      console.log(e);
    }
  }

  async function getMedia(deviceId) {
    const initialConstrains = {
      audio: true,
      video: { facingMode: "user" }
    };
    const cameraConstrains = {
      audio: true,
      video: { deviceId: { exact: deviceId } }
    };
    try {
      myStream = await navigator.mediaDevices.getUserMedia(
        deviceId ? cameraConstrains : initialConstrains
      );
      myFace.srcObject = myStream;
      if (!deviceId) {
        await getCameras();
      }
    } catch (e) {
      console.log(e);
    }
  }

  async function initCall() {
    welcome.hidden = true;
    call.hidden = false;
    await getMedia();
    makeConnection();
  }

  async function join(email) {
    await initCall();
    roomName = "1234";
    socket.emit("join_room", { room: roomName, email: email });
  }

  function makeConnection() {
    myPeerConnection = new RTCPeerConnection({
      iceServers: [
        {
          urls: [
            "stun:stun.l.google.com:19302",
            "stun:stun1.l.google.com:19302",
            "stun:stun2.l.google.com:19302",
            "stun:stun3.l.google.com:19302",
            "stun:stun4.l.google.com:19302"
          ]
        }
      ]
    });
    myPeerConnection.addEventListener("icecandidate", handleIce);
    myPeerConnection.addEventListener("addstream", handleAddStream);
    myStream.getTracks().forEach(track => myPeerConnection.addTrack(track, myStream));
  }

  function handleIce(data) {
    console.log("sent the candidate");
    socket.emit("ice", data.candidate);
  }

  // 받아온 stream을 출력
  function handleAddStream(data) {
    console.log("got an event from my peer");
    const peerFace = document.getElementById("peerFace");
    peerFace.srcObject = data.stream;
  }


  // ===========================================================================

  function handleMuteClick() {
    myStream.getAudioTracks().forEach(track => {
      track.enabled = !track.enabled;
    });

    if (!muted) {
      muteBtn.innerText = "Unmute";
      muted = true;
    } else {
      muteBtn.innerText = "Mute";
      muted = false;
    }
  }

  function handleCameraClick() {
    myStream.getVideoTracks().forEach(track => {
      track.enabled = !track.enabled;
    });
    if (cameraOff) {
      cameraBtn.innerText = "Turn Camera Off";
      cameraOff = false;
    } else {
      cameraBtn.innerText = "Turn Camera On";
      cameraOff = true;
    }
  }

  async function handleCameraChange() {
    await getMedia(camerasSelect.value);
    if (myPeerConnection) {
      const videoTrack = myStream.getVideoTracks()[0];
      const videoSender = myPeerConnection.getSenders()
        .find((sender) => sender.track.kind === "video");
      await videoSender.replaceTrack(videoTrack);
    }
  }

  muteBtn.addEventListener("click", handleMuteClick);
  cameraBtn.addEventListener("click", handleCameraClick);
  camerasSelect.addEventListener("input", handleCameraChange);

  // ===========================================================================

  // 먼저 들어온 놈
  socket.on("all_users", async (allUsers) => {
    let length = allUsers.length;
    if (length > 0) {
      // create offer
      const offer = await myPeerConnection.createOffer();
      await myPeerConnection.setLocalDescription(offer);
      console.log("sent the offer");
      socket.emit("offer", offer);
    }
  });

  // 나중에 들어온 놈
  socket.on("getOffer", async (offer) => {
    console.log("received the offer");
    // create answer
    await myPeerConnection.setRemoteDescription(offer);
    const answer = await myPeerConnection.createAnswer();
    await myPeerConnection.setLocalDescription(answer);
    socket.emit("answer", answer);
    console.log("sent the answer");
  });

  // 먼저 들어온 놈
  socket.on("getAnswer", async (answer) => {
    console.log("received the answer");
    await myPeerConnection.setRemoteDescription(answer);
  });

  socket.on("getIce", (ice) => {
    myPeerConnection.addIceCandidate(ice).then(() => console.log("received the candidate"));
  });

</script>
</body>
</html>